import picoSanity from 'picosanity';
import getImageUrlBuilder from '@sanity/image-url';
import React, { useState, useEffect } from 'react';
import { useDeepCompareEffectNoCheck } from 'use-deep-compare-effect';
import SanityPortableText from '@sanity/block-content-to-react';
export { default as groq } from 'groq';

function createClient(config) {
  return picoSanity(config);
}

function createImageUrlBuilder(_ref) {
  let projectId = _ref.projectId,
      dataset = _ref.dataset;
  return getImageUrlBuilder({
    projectId,
    dataset
  });
}

function getAborter() {
  return typeof AbortController === 'undefined' ? {
    signal: undefined,
    abort: noop
  } : new AbortController();
}

function noop() {// intentional noop
}

function createCurrentUserHook(_ref) {
  let projectId = _ref.projectId;
  return () => useCurrentUser(projectId);
}
function getCurrentUser(projectId, abort) {
  return fetch("https://" + projectId + ".api.sanity.io/v1/users/me", {
    credentials: 'include',
    signal: abort == null ? void 0 : abort.signal
  }).then(res => res.json()).then(res => (res == null ? void 0 : res.id) ? res : null).catch(err => err.name === 'AbortError' ? null : Promise.reject(err));
}

function useCurrentUser(projectId) {
  const _useState = useState(),
        data = _useState[0],
        setUser = _useState[1];

  const _useState2 = useState(),
        error = _useState2[0],
        setError = _useState2[1];

  useEffect(() => {
    const aborter = getAborter();
    getCurrentUser(projectId, aborter).then(setUser).catch(setError);
    return () => aborter.abort();
  }, [projectId]);
  return {
    data,
    error,
    loading: data !== null || !error
  };
}

function createPreviewSubscriptionHook(_ref) {
  let projectId = _ref.projectId,
      dataset = _ref.dataset,
      _ref$documentLimit = _ref.documentLimit,
      documentLimit = _ref$documentLimit === void 0 ? 3000 : _ref$documentLimit;
  // Only construct/setup the store when `getStore()` is called
  let store;
  return function usePreviewSubscription(query, options) {
    if (options === void 0) {
      options = {};
    }

    const _options = options,
          _options$params = _options.params,
          params = _options$params === void 0 ? {} : _options$params,
          initialData = _options.initialData,
          enabled = _options.enabled;
    return useQuerySubscription({
      getStore,
      projectId,
      query,
      params,
      initialData: initialData,
      enabled: enabled ? typeof window !== 'undefined' : false
    });
  };

  function getStore() {
    if (!store) {
      store = import('@sanity/groq-store').then((_ref2) => {
        let groqStore = _ref2.groqStore;
        return groqStore({
          projectId,
          dataset,
          documentLimit,
          listen: true,
          overlayDrafts: true,
          subscriptionThrottleMs: 10
        });
      });
    }

    return store;
  }
}

function useQuerySubscription(options) {
  const getStore = options.getStore,
        projectId = options.projectId,
        query = options.query,
        params = options.params,
        initialData = options.initialData,
        _options$enabled = options.enabled,
        enabled = _options$enabled === void 0 ? false : _options$enabled;

  const _useState = useState(),
        error = _useState[0],
        setError = _useState[1];

  const _useState2 = useState(false),
        loading = _useState2[0],
        setLoading = _useState2[1];

  const _useState3 = useState(),
        data = _useState3[0],
        setData = _useState3[1]; // Use "deep" dependency comparison because params are often not _referentially_ equal,
  // but contains the same shallow properties, eg `{"slug": "some-slug"}`


  useDeepCompareEffectNoCheck(() => {
    if (!enabled) {
      return () => {
        /* intentional noop */
      };
    }

    setLoading(true);
    const aborter = getAborter();
    let subscription;
    getCurrentUser(projectId, aborter).then(user => {
      if (user) {
        return;
      } // eslint-disable-next-line no-console


      console.warn('Not authenticated - preview not available');
      throw new Error('Not authenticated - preview not available');
    }).then(getStore).then(store => {
      subscription = store.subscribe(query, params, (err, result) => {
        if (err) {
          setError(err);
        } else {
          setData(result);
        }
      });
    }).catch(setError).finally(() => setLoading(false));
    return () => {
      if (subscription) {
        subscription.unsubscribe();
      }

      aborter.abort();
    };
  }, [getStore, query, params, enabled]);
  return {
    data: typeof data === 'undefined' ? initialData : data,
    loading,
    error
  };
}

function createPortableTextComponent(_ref) {
  let projectId = _ref.projectId,
      dataset = _ref.dataset,
      serializers = _ref.serializers;
  return function PortableText(props) {
    return React.createElement(SanityPortableText, Object.assign({
      projectId: projectId,
      dataset: dataset,
      serializers: serializers
    }, props));
  };
}

export { createClient, createCurrentUserHook, createImageUrlBuilder, createPortableTextComponent, createPreviewSubscriptionHook };
//# sourceMappingURL=next-sanity.esm.js.map
