import { InitConfig } from "../resources/Initialize";
export interface GeneralObject {
    [index: string]: string;
}
export interface HeaderParams {
    Authorization: string;
}
export interface HeadersResponse {
    connection: string;
    server: string;
    'x-frame-options': string;
    'x-xss-protection': string;
    'x-content-type-options': string;
    'x-download-options': string;
    'x-permitted-cross-domain-policies': string;
    'referrer-policy': string;
    'x-ratelimit-limit': string;
    'x-ratelimit-count': string;
    'x-ratelimit-period': string;
    'content-type': string;
    etag: string;
    'cache-control': string;
    'x-request-id': string;
    'strict-transport-security': string;
    via: string;
    'accept-ranges': string;
    age: string;
    date: string;
    'x-served-by': string;
    'x-cache': string;
    'x-cache-hits': string;
    'x-timer': string;
    vary: string;
    'transfer-encoding': string;
}
export interface BaseConfig {
    className?: string;
    polymorphic?: boolean;
    as?: string;
    inverseOf?: string;
    autosave?: boolean;
}
export interface Base {
    resourceLibrary: {
        baseUrl: string;
        headers: {
            Authorization: string;
        };
    };
    __links: object;
    new (): Base;
    attributes(...attribute: string[]): void;
    hasOne(queryName: string, config: BaseConfig): void;
    hasMany(queryName: string, config: BaseConfig): void;
    belongsTo(queryName: string, config: BaseConfig): void;
    define(): void;
    className: string;
    queryName: string;
    __queryParams: object;
    __newRelation(r: any): any;
    __extendObjectParam(type: string, options: object): any;
    afterRequest(callback: () => void): void;
    afterBuild(callback: () => void): void;
    afterCreate(callback: () => void): void;
    update(attrs: object, callback?: (res: any) => any): any;
    destroy(): Promise<any>;
    withCredentials({ accessToken, endpoint }: InitConfig): Base;
    find(primaryKey: string): Promise<any>;
    errors(): Errors<any>;
    setCustomInterceptors(interceptors: InitConfig['interceptors']): Base;
}
export interface BaseResource<T = any> extends Omit<Base, 'withCredentials' | 'setCustomInterceptors'> {
    (): BaseResource;
    all(): Promise<CollectionResponse<T>> & SingleRelationship<Partial<T>>;
    assignQueryParams(queryParams: object): object;
    assignResourceRelatedQueryParams(queryParams: object): object;
    assignAttributes(values: object): object;
    attributes(): {
        all: any;
        read: any;
        readWrite: any;
    };
    build(params?: object): Collection<T> | CollectionResponse<T>;
    create(attributes: object): Promise<T>;
    each(iteratee: any): any;
    fields(): Collection<T>;
    find(primaryKey: string): Promise<T>;
    findBy(conditions: object): Promise<T>;
    first(): Promise<T>;
    first(n: number): Promise<T[]>;
    includes(...attribute: string[]): BaseResource<T>;
    isA(klass: BaseResource<T>): boolean;
    klass(): BaseResource<T>;
    last(): Promise<T>;
    last(n: number): Promise<T[]>;
    limit(n?: number): BaseResource<T>;
    links(): {
        related: string;
    };
    offset(n?: number): BaseResource<T>;
    order(args: object): BaseResource<T>;
    page(n: number): BaseResource<T>;
    perPage(n: number): BaseResource<T>;
    primaryKey: string;
    queryParams(): object;
    resetQueryParams(): object;
    select(...params: Array<string | Record<string, string[]>>): BaseResource<T>;
    where(options?: object): BaseResource<T>;
    update(attrs: object, callback?: any): Promise<T>;
    withCredentials({ accessToken, endpoint }: InitConfig): BaseResource<T>;
    setCustomInterceptors(interceptors: InitConfig['interceptors']): BaseResource<T>;
}
export interface Relation extends Collection {
    base: Base;
    define(): any;
    queryName: string;
    __queryParams: {
        include: any[];
    };
}
export interface LinksRelationships {
    first: string;
    next: string;
    last: string;
}
export declare type MetaInformation = {
    pageCount?: number;
    mode?: string;
    recordCount?: number;
};
export interface CollectionResponse<T = any> {
    __collection: Collection[];
    __links: LinksRelationships;
    hasNextPage: () => boolean;
    hasPrevPage: () => boolean;
    links(): LinksRelationships | null;
    nextPage(): Promise<CollectionResponse<T>>;
    prevPage(): Promise<CollectionResponse<T>>;
    toCollection(): Collection;
    all(): T[];
    clear(): [];
    clone(): T[];
    compact(iteratee: any): any;
    delete(): any;
    detect(predicate: any): any;
    each(iteratee: any): any;
    empty(): boolean;
    first(): T;
    first(n: number): T[];
    flatten(): any;
    get(index: number): T;
    includes(...attribute: string[]): CollectionResponse<T>;
    load(): Promise<CollectionResponse<T>>;
    indexOf(item: any): any;
    inject(memo: object, interatee: any): any;
    join(): string;
    last(): T;
    last(n: number): T[];
    map(iteratee: (param: T) => any): void;
    pop(): T;
    push(): number;
    replace(original: any, next: any): any;
    select(predicate?: any): CollectionResponse<T>;
    set(index: number, item: BaseResource): Collection;
    shift(): T;
    toArray(): T[];
    unshift(): T;
    size(): number;
    getHeaders(): HeadersResponse;
    getMetaInfo(): MetaInformation;
    pageCount(): MetaInformation['pageCount'];
    recordCount(): MetaInformation['recordCount'];
    withCredentials({ accessToken, endpoint }: InitConfig): CollectionResponse<T>;
}
export interface CollectionProxy<P> extends Pick<BaseResource<P>, 'where'> {
    all(): Promise<CollectionResponse<P>>;
    load(): Promise<CollectionResponse<P>>;
    empty(): boolean;
    size(): boolean;
    target(): CollectionResponse<P>;
    toArray(): P[];
    find(primaryKey: string): Promise<P>;
    findBy(conditions: object): Promise<P>;
    includes(...attribute: string[]): CollectionProxy<P>;
}
export interface Collection<R = any> {
    association(name: string): any;
    attributes(): object;
    changed(): boolean;
    changedFields(): Collection<R>;
    clone(): Collection<R>;
    destroy(): Collection<R>;
    errors(): Errors<R>;
    hasAttribute(attribute: string): boolean;
    isA(klass: BaseResource): boolean;
    klass(): BaseResource;
    links(): {
        related: string;
        self: string;
    };
    newResource(): boolean;
    map(iteratee: (param: Collection) => any): void;
    persisted(): any;
    queryParams(): object;
    queryParamsForReflection(): any;
    reload(): any;
    save(callback?: any): any;
    update(attrs: object, callback?: any): Collection<R>;
    valid(): boolean;
}
export declare type SingleRelationship<R> = (R & Promise<R>) | null;
export declare type MultiRelationship<R> = (CollectionProxy<R> & Promise<CollectionProxy<R>>) | null;
export interface CreateResource {
    createResource<R>(resource: Base): BaseResource<R>;
}
export interface Errors<T = any> {
    (): T;
    base: T;
    empty(): boolean;
    toArray(): T[];
    toCollection(): Collection<T>;
}
export default interface Library extends CreateResource {
    customRequests: {
        [key: string]: {
            [key: string]: {
                [key: string]: object;
            };
        };
    };
    interface: {
        toCamelCase: <T extends any>(value: T) => T;
    };
    singleRequest: boolean;
    baseUrl: string;
    headers: {
        Authorization: string;
    };
    Base: Base;
    customInterceptors?: InitConfig['interceptors'];
}
