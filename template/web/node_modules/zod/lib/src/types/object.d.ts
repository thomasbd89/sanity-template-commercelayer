import * as z from './base';
import { ZodUndefined } from './undefined';
import { ZodUnion } from './union';
import { objectUtil } from '../helpers/objectUtil';
import { partialUtil } from '../helpers/partialUtil';
export interface ZodObjectDef<T extends z.ZodRawShape = z.ZodRawShape, Params extends ZodObjectParams = ZodObjectParams> extends z.ZodTypeDef {
    t: z.ZodTypes.object;
    shape: () => T;
    params: Params;
}
interface ZodObjectParams {
    strict: boolean;
}
export declare type Scalars = string | string[] | number | number[] | boolean | boolean[] | bigint | bigint[] | undefined | null;
declare type SetKey<Target extends object, Key extends string, Value extends any> = objectUtil.Flatten<{
    [k in Exclude<keyof Target, Key>]: Target[k];
} & {
    [k in Key]: Value;
}>;
declare type ZodObjectType<T extends z.ZodRawShape, Params extends ZodObjectParams> = Params['strict'] extends true ? objectUtil.ObjectType<T> : objectUtil.Flatten<objectUtil.ObjectType<T> & {
    [k: string]: any;
}>;
export declare class ZodObject<T extends z.ZodRawShape, Params extends ZodObjectParams = {
    strict: true;
}, Type extends ZodObjectType<T, Params> = ZodObjectType<T, Params>> extends z.ZodType<Type, ZodObjectDef<T, Params>> {
    readonly _shape: T;
    readonly _params: Params;
    get shape(): T;
    get params(): Params;
    toJSON: () => {
        t: z.ZodTypes.object;
        shape: {
            [x: string]: any;
        }[];
    };
    nonstrict: () => ZodObject<T, SetKey<Params, 'strict', false>>;
    augment: <Augmentation extends z.ZodRawShape>(augmentation: Augmentation) => ZodObject<{ [k in Exclude<keyof T, keyof Augmentation>]: T[k]; } & { [k_1 in keyof Augmentation]: Augmentation[k_1]; }, Params, ZodObjectType<{ [k in Exclude<keyof T, keyof Augmentation>]: T[k]; } & { [k_1 in keyof Augmentation]: Augmentation[k_1]; }, Params>>;
    extend: <Augmentation extends z.ZodRawShape>(augmentation: Augmentation) => ZodObject<{ [k in Exclude<keyof T, keyof Augmentation>]: T[k]; } & { [k_1 in keyof Augmentation]: Augmentation[k_1]; }, Params, ZodObjectType<{ [k in Exclude<keyof T, keyof Augmentation>]: T[k]; } & { [k_1 in keyof Augmentation]: Augmentation[k_1]; }, Params>>;
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge: <MergeShape extends z.ZodRawShape, MergeParams extends ZodObjectParams>(other: ZodObject<MergeShape, MergeParams>) => ZodObject<T & MergeShape, objectUtil.MergeObjectParams<Params, MergeParams>>;
    pick: <Mask extends { [k in keyof T]?: true | undefined; }>(mask: Mask) => ZodObject<{ [k_2 in objectUtil.NoNeverKeys<{ [k_1 in keyof Mask]: k_1 extends keyof T ? T[k_1] : never; }>]: k_2 extends keyof Mask ? { [k_1 in keyof Mask]: k_1 extends keyof T ? T[k_1] : never; }[k_2] : never; }, Params, ZodObjectType<{ [k_2 in objectUtil.NoNeverKeys<{ [k_1 in keyof Mask]: k_1 extends keyof T ? T[k_1] : never; }>]: k_2 extends keyof Mask ? { [k_1 in keyof Mask]: k_1 extends keyof T ? T[k_1] : never; }[k_2] : never; }, Params>>;
    omit: <Mask extends { [k in keyof T]?: true | undefined; }>(mask: Mask) => ZodObject<{ [k_2 in objectUtil.NoNeverKeys<{ [k_1 in keyof T]: k_1 extends keyof Mask ? never : T[k_1]; }>]: k_2 extends keyof T ? { [k_1 in keyof T]: k_1 extends keyof Mask ? never : T[k_1]; }[k_2] : never; }, Params, ZodObjectType<{ [k_2 in objectUtil.NoNeverKeys<{ [k_1 in keyof T]: k_1 extends keyof Mask ? never : T[k_1]; }>]: k_2 extends keyof T ? { [k_1 in keyof T]: k_1 extends keyof Mask ? never : T[k_1]; }[k_2] : never; }, Params>>;
    partial: () => ZodObject<{ [k in keyof T]: ZodUnion<[T[k], ZodUndefined]>; }, Params, ZodObjectType<{ [k in keyof T]: ZodUnion<[T[k], ZodUndefined]>; }, Params>>;
    primitives: () => ZodObject<{ [k_1 in objectUtil.NoNeverKeys<{ [k in keyof T]: [T[k]["_type"]] extends [Scalars] ? T[k] : never; }>]: k_1 extends keyof T ? { [k in keyof T]: [T[k]["_type"]] extends [Scalars] ? T[k] : never; }[k_1] : never; }, Params, ZodObjectType<{ [k_1 in objectUtil.NoNeverKeys<{ [k in keyof T]: [T[k]["_type"]] extends [Scalars] ? T[k] : never; }>]: k_1 extends keyof T ? { [k in keyof T]: [T[k]["_type"]] extends [Scalars] ? T[k] : never; }[k_1] : never; }, Params>>;
    nonprimitives: () => ZodObject<{ [k_1 in objectUtil.NoNeverKeys<{ [k in keyof T]: [T[k]["_type"]] extends [Scalars] ? never : T[k]; }>]: k_1 extends keyof T ? { [k in keyof T]: [T[k]["_type"]] extends [Scalars] ? never : T[k]; }[k_1] : never; }, Params, ZodObjectType<{ [k_1 in objectUtil.NoNeverKeys<{ [k in keyof T]: [T[k]["_type"]] extends [Scalars] ? never : T[k]; }>]: k_1 extends keyof T ? { [k in keyof T]: [T[k]["_type"]] extends [Scalars] ? never : T[k]; }[k_1] : never; }, Params>>;
    deepPartial: () => partialUtil.RootDeepPartial<this>;
    static create: <T_1 extends z.ZodRawShape>(shape: T_1) => ZodObject<T_1, {
        strict: true;
    }, { [k_4 in keyof ({ [k_2 in { [k_1 in keyof { [k in keyof T_1]: T_1[k]["_type"]; }]: undefined extends { [k in keyof T_1]: T_1[k]["_type"]; }[k_1] ? k_1 : never; }[keyof T_1]]?: { [k in keyof T_1]: T_1[k]["_type"]; }[k_2] | undefined; } & { [k_3 in Exclude<keyof T_1, { [k_1 in keyof { [k in keyof T_1]: T_1[k]["_type"]; }]: undefined extends { [k in keyof T_1]: T_1[k]["_type"]; }[k_1] ? k_1 : never; }[keyof T_1]>]: { [k in keyof T_1]: T_1[k]["_type"]; }[k_3]; })]: ({ [k_2 in { [k_1 in keyof { [k in keyof T_1]: T_1[k]["_type"]; }]: undefined extends { [k in keyof T_1]: T_1[k]["_type"]; }[k_1] ? k_1 : never; }[keyof T_1]]?: { [k in keyof T_1]: T_1[k]["_type"]; }[k_2] | undefined; } & { [k_3 in Exclude<keyof T_1, { [k_1 in keyof { [k in keyof T_1]: T_1[k]["_type"]; }]: undefined extends { [k in keyof T_1]: T_1[k]["_type"]; }[k_1] ? k_1 : never; }[keyof T_1]>]: { [k in keyof T_1]: T_1[k]["_type"]; }[k_3]; })[k_4]; }>;
    static lazycreate: <T_1 extends z.ZodRawShape>(shape: () => T_1) => ZodObject<T_1, {
        strict: true;
    }, { [k_4 in keyof ({ [k_2 in { [k_1 in keyof { [k in keyof T_1]: T_1[k]["_type"]; }]: undefined extends { [k in keyof T_1]: T_1[k]["_type"]; }[k_1] ? k_1 : never; }[keyof T_1]]?: { [k in keyof T_1]: T_1[k]["_type"]; }[k_2] | undefined; } & { [k_3 in Exclude<keyof T_1, { [k_1 in keyof { [k in keyof T_1]: T_1[k]["_type"]; }]: undefined extends { [k in keyof T_1]: T_1[k]["_type"]; }[k_1] ? k_1 : never; }[keyof T_1]>]: { [k in keyof T_1]: T_1[k]["_type"]; }[k_3]; })]: ({ [k_2 in { [k_1 in keyof { [k in keyof T_1]: T_1[k]["_type"]; }]: undefined extends { [k in keyof T_1]: T_1[k]["_type"]; }[k_1] ? k_1 : never; }[keyof T_1]]?: { [k in keyof T_1]: T_1[k]["_type"]; }[k_2] | undefined; } & { [k_3 in Exclude<keyof T_1, { [k_1 in keyof { [k in keyof T_1]: T_1[k]["_type"]; }]: undefined extends { [k in keyof T_1]: T_1[k]["_type"]; }[k_1] ? k_1 : never; }[keyof T_1]>]: { [k in keyof T_1]: T_1[k]["_type"]; }[k_3]; })[k_4]; }>;
}
export {};
