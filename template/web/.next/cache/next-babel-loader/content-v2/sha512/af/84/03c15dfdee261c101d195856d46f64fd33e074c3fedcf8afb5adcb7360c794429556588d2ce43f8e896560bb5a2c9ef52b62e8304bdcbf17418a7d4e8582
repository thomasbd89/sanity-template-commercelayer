{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport sanityClient from '@sanity/client';\nimport { parseLocale } from '@utils/parser';\nimport _ from 'lodash';\nconst client = sanityClient({\n  projectId: \"<#< sanity.projectId >#>\",\n  dataset: \"<#< sanity.dataset >#>\",\n  token: process.env.SANITY_TOKEN,\n  // or leave blank to be anonymous user\n  useCdn: false // `false` if you want to ensure fresh data\n\n});\n\nconst sanityAllCountries = async (locale = 'en-US') => {\n  const lang = parseLocale(locale, '_', '-', 'lowercase');\n  const query = `*[_type == \"country\"]{\n    name,\n    code,\n    marketId,\n    defaultLocale,\n    \"image\": {\n      \"url\": image.asset->url\n    },\n    'catalog': {\n      'id': catalog->_id\n    }\n  } | order(name[\"${lang}\"] asc)`;\n  const countries = await client.fetch(query);\n  return countries.map(country => {\n    const localization = {\n      name: country === null || country === void 0 ? void 0 : country.name[lang]\n    };\n    return _objectSpread(_objectSpread({}, country), localization);\n  });\n};\n\nconst parsingVariant = (variants, lang = 'en_us') => {\n  return !_.isEmpty(variants) ? variants.map(variant => {\n    var _variant$name, _variant$size, _variant$size$name;\n\n    const localization = {\n      name: (variant === null || variant === void 0 ? void 0 : (_variant$name = variant.name) === null || _variant$name === void 0 ? void 0 : _variant$name[lang]) || '',\n      size: {\n        name: (variant === null || variant === void 0 ? void 0 : (_variant$size = variant.size) === null || _variant$size === void 0 ? void 0 : (_variant$size$name = _variant$size.name) === null || _variant$size$name === void 0 ? void 0 : _variant$size$name[lang]) || ''\n      }\n    };\n    return _objectSpread(_objectSpread({}, variant), localization);\n  }) : [];\n};\n\nconst parsingProduct = (products, lang = 'en_us') => {\n  return _.isArray(products) ? products.map(product => {\n    const localization = {\n      name: product === null || product === void 0 ? void 0 : product.name[lang],\n      slug: product === null || product === void 0 ? void 0 : product.slug[lang].current,\n      description: product === null || product === void 0 ? void 0 : product.description[lang],\n      variants: parsingVariant(product === null || product === void 0 ? void 0 : product.variants, lang)\n    };\n    return _objectSpread(_objectSpread({}, product), localization);\n  }) : _objectSpread(_objectSpread({}, products), {}, {\n    name: products === null || products === void 0 ? void 0 : products.name[lang],\n    slug: products === null || products === void 0 ? void 0 : products.slug[lang].current,\n    description: products === null || products === void 0 ? void 0 : products.description[lang],\n    variants: parsingVariant(products === null || products === void 0 ? void 0 : products.variants, lang)\n  });\n};\n\nconst parsingTaxon = (taxons, lang = 'en_us') => {\n  return taxons.map(taxon => {\n    const localization = {\n      name: taxon === null || taxon === void 0 ? void 0 : taxon.name[lang],\n      label: taxon === null || taxon === void 0 ? void 0 : taxon.label[lang],\n      products: taxon !== null && taxon !== void 0 && taxon.products ? parsingProduct(taxon.products, lang) : []\n    };\n    return _objectSpread(_objectSpread({}, taxon), localization);\n  });\n};\n\nconst parsingTaxonomies = (taxonomies, locale = 'en-US') => {\n  const lang = parseLocale(locale, '_', '-', 'lowercase');\n  const items = taxonomies.map(taxonomy => {\n    const localization = {\n      name: taxonomy === null || taxonomy === void 0 ? void 0 : taxonomy.name[lang],\n      label: taxonomy === null || taxonomy === void 0 ? void 0 : taxonomy.label[lang],\n      taxons: parsingTaxon(taxonomy === null || taxonomy === void 0 ? void 0 : taxonomy.taxons, lang)\n    };\n    return _objectSpread(_objectSpread({}, taxonomy), localization);\n  });\n  return items;\n};\n\nconst sanityAllTaxonomies = async (catalogId, locale = 'en-US') => {\n  var _$first;\n\n  // const newLocale = getLocale(locale)\n  const query = `*[_type == \"catalog\" && _id == '${catalogId}']{\n    'taxonomies': taxonomies[]->{\n      label,\n      name,\n      'taxons': taxons[]->{\n        label,\n        name,\n        'products': products[]->{\n          name,\n          description,\n          reference,\n          slug,\n          'images': images[]->{\n            'url': images.asset->url\n          },\n          'variants': variants[]->{\n            code,\n            name,\n            size->,\n          }    \n        }\n      }\n    }\n  }  | order(name asc)`;\n  const items = await client.fetch(query);\n  return parsingTaxonomies((_$first = _.first(items)) === null || _$first === void 0 ? void 0 : _$first.taxonomies, locale);\n};\n\nconst sanityGetProduct = async (slug, locale = 'en-US') => {\n  const lang = parseLocale(locale, '_', '-', 'lowercase');\n  const query = `*[_type == \"product\" && slug[\"${lang}\"].current == \"${slug}\"]{\n    name,\n    description,\n    reference,\n    slug,\n    'images': images[]->{\n      'url': images.asset->url\n    },\n    'variants': variants[]->{\n      label,\n      code,\n      name,\n      size->,\n      'images': images[]->{\n        'url': images.asset->url\n      }\n    }    \n  }`;\n  const item = await client.fetch(query);\n  return parsingProduct(_.first(item), lang);\n};\n\nexport default {\n  sanityAllCountries,\n  sanityAllTaxonomies,\n  sanityGetProduct\n};","map":{"version":3,"sources":["/Users/bolajiayodeji/Tunnel/CL/sanity-commercelayer-starter/template/web/utils/sanity/api.ts"],"names":["sanityClient","parseLocale","_","client","projectId","dataset","token","process","env","SANITY_TOKEN","useCdn","sanityAllCountries","locale","lang","query","countries","fetch","map","country","localization","name","parsingVariant","variants","isEmpty","variant","size","parsingProduct","products","isArray","product","slug","current","description","parsingTaxon","taxons","taxon","label","parsingTaxonomies","taxonomies","items","taxonomy","sanityAllTaxonomies","catalogId","first","sanityGetProduct","item"],"mappings":"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","sourcesContent":["import sanityClient from '@sanity/client'\nimport { Product, Taxon, Taxonomy, Variant } from '@typings/models'\nimport { parseLocale } from '@utils/parser'\nimport _ from 'lodash'\nimport {\n  SanityCountry,\n  SanityProduct,\n  SanityTaxon,\n  SanityTaxonomy,\n  SanityVariant,\n} from './typings'\n\nconst client = sanityClient({\n  projectId: \"<#< sanity.projectId >#>\" as string,\n  dataset: \"<#< sanity.dataset >#>\" as string,\n  token: process.env.SANITY_TOKEN as string, // or leave blank to be anonymous user\n  useCdn: process.env.NODE_ENV === 'production', // `false` if you want to ensure fresh data\n})\n\nconst sanityAllCountries = async (locale = 'en-US') => {\n  const lang = parseLocale(locale, '_', '-', 'lowercase')\n  const query = `*[_type == \"country\"]{\n    name,\n    code,\n    marketId,\n    defaultLocale,\n    \"image\": {\n      \"url\": image.asset->url\n    },\n    'catalog': {\n      'id': catalog->_id\n    }\n  } | order(name[\"${lang}\"] asc)`\n  const countries = await client.fetch<SanityCountry[]>(query)\n  return countries.map((country) => {\n    const localization = {\n      name: country?.name[lang],\n    }\n    return { ...country, ...localization }\n  })\n}\n\nconst parsingVariant = (\n  variants: SanityVariant[],\n  lang = 'en_us'\n): Variant[] => {\n  return !_.isEmpty(variants)\n    ? variants.map((variant) => {\n        const localization = {\n          name: variant?.name?.[lang] || '',\n          size: { name: variant?.size?.name?.[lang] || '' },\n        }\n        return { ...variant, ...localization }\n      })\n    : []\n}\n\nconst parsingProduct = (\n  products: SanityProduct[] | SanityProduct,\n  lang = 'en_us'\n): Product[] | Product => {\n  return _.isArray(products)\n    ? products.map((product) => {\n        const localization = {\n          name: product?.name[lang],\n          slug: product?.slug[lang].current,\n          description: product?.description[lang],\n          variants: parsingVariant(product?.variants, lang) as Variant[],\n        }\n        return { ...product, ...localization }\n      })\n    : {\n        ...products,\n        name: products?.name[lang],\n        slug: products?.slug[lang].current,\n        description: products?.description[lang],\n        variants: parsingVariant(products?.variants, lang) as Variant[],\n      }\n}\n\nconst parsingTaxon = (taxons: SanityTaxon[], lang = 'en_us'): Taxon[] => {\n  return taxons.map((taxon) => {\n    const localization = {\n      name: taxon?.name[lang],\n      label: taxon?.label[lang],\n      products: taxon?.products\n        ? (parsingProduct(taxon.products, lang) as Product[])\n        : [],\n    }\n    return { ...taxon, ...localization }\n  })\n}\n\nconst parsingTaxonomies = (\n  taxonomies: SanityTaxonomy[],\n  locale = 'en-US'\n): Taxonomy[] => {\n  const lang = parseLocale(locale, '_', '-', 'lowercase')\n  const items = taxonomies.map((taxonomy) => {\n    const localization = {\n      name: taxonomy?.name[lang],\n      label: taxonomy?.label[lang],\n      taxons: parsingTaxon(taxonomy?.taxons, lang),\n    }\n    return { ...taxonomy, ...localization }\n  })\n  return items\n}\nconst sanityAllTaxonomies = async (catalogId: string, locale = 'en-US') => {\n  // const newLocale = getLocale(locale)\n  const query = `*[_type == \"catalog\" && _id == '${catalogId}']{\n    'taxonomies': taxonomies[]->{\n      label,\n      name,\n      'taxons': taxons[]->{\n        label,\n        name,\n        'products': products[]->{\n          name,\n          description,\n          reference,\n          slug,\n          'images': images[]->{\n            'url': images.asset->url\n          },\n          'variants': variants[]->{\n            code,\n            name,\n            size->,\n          }    \n        }\n      }\n    }\n  }  | order(name asc)`\n  const items: any[] = await client.fetch(query)\n  return parsingTaxonomies(_.first(items)?.taxonomies, locale)\n}\n\nconst sanityGetProduct = async (slug: string, locale = 'en-US') => {\n  const lang = parseLocale(locale, '_', '-', 'lowercase')\n  const query = `*[_type == \"product\" && slug[\"${lang}\"].current == \"${slug}\"]{\n    name,\n    description,\n    reference,\n    slug,\n    'images': images[]->{\n      'url': images.asset->url\n    },\n    'variants': variants[]->{\n      label,\n      code,\n      name,\n      size->,\n      'images': images[]->{\n        'url': images.asset->url\n      }\n    }    \n  }`\n  const item: any[] = await client.fetch(query)\n  return parsingProduct(_.first(item), lang)\n}\n\nexport default {\n  sanityAllCountries,\n  sanityAllTaxonomies,\n  sanityGetProduct,\n}\n"]},"metadata":{},"sourceType":"module"}